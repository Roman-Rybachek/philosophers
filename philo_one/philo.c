/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   philo.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jeldora <jeldora@student.21-school.ru>     +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/11/14 08:32:27 by jeldora           #+#    #+#             */
/*   Updated: 2020/11/14 09:44:34 by jeldora          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "header.h"

void	right_philo(t_philo *philo, t_data *data)
{
	t_philo *right_philo;

	if (philo->index = data->philo_nbr - 1)
		right_philo = data->philos[0];
	else
		right_philo = data->philos[philo->index + 1];
	if (philo->to_death > right_philo->to_death + data->eating_time && \
		philo->have_r)
	{
		pthread_mutex_unlock(philo->r_fork);
		philo->have_r = 0;
	}
}

void	left_philo(t_philo *philo, t_data *data)
{
	t_philo *left_philo;

	if (philo->index = 0)
		left_philo = data->philos[data->philo_nbr - 1];
	else
		left_philo = data->philos[philo->index - 1];
	if (philo->to_death > left_philo->to_death + data->eating_time && \
		philo->have_l)
	{
		pthread_mutex_unlock(philo->l_fork);
		philo->have_l = 0;
	}
}

void	monitoring(void *p)
{
	t_data		*data;
	t_philo		*philo

	philo = (t_philo*)p;
	data = ((t_data*)philo->data);
	while(1)
	{
		philo->to_death = get_time() - philo->last_eat;
		right_philo(philo, data);
		left_philo(philo, data);
		if (philo->have_l && philo->have_r)
			philo->last_eat = get_time();
	}
}


/*	Нельзя, чтобы рядом оказались два узла, у которых осталось одинаково мало времени.
	Соответственно, нужно, чтобы находились узлы с самыми маленькими интервалами и 
	увеличивали интервал друг между другом. Как это сделать? За счет тех, у кого много
	времени. Они не должны есть при первой же возможности.

	Значение параметров:
	время еды - сколько нужно ждать философу, чтобы получить вилку.
	сон - штраф к времени жизни.

	по сути, у философа есть "время жизни" минус "сон" на то, чтобы получить вилки
	впринципе, нужно чтобы один из философов поел дважды, и этого будет достаточно для 
	разрыва (скорее всего)
	поесть должен тот, у кого более жевучий сосед.

	также, должно быть базовое поведение.
	Т.е. будет поведение двух наименьших, и базовое поведение.

 */

/* нужно выявить слабое звено, и делать его более приорететным */
/* нужно сделать цикл, который будет проходить по всем философам и рассчитывать 
будущее слабое звено.
	
 У философов будет несколько состояний.
 1) Ест
 2) Спит
 3) Слабое звено (меньше всего времени осталось)
 4) Больше всего времени осталось

 После того, как философ поел, жить ему осталось
 время жизни - сон - время 


 Как расчитать слабое звено?
 Слабое звено, это тот, кому меньше всего осталось жить.
 Допустим, мы сравнили всех, и выяснили, кому меньше жить.
 Затем нужно выяснить второе после него слабое звено.
 
 Нет, система должна наперед просчитать, какое из звеньев обречено, и исправить
 ситуацию искусственно. 

*/